{
  parserClass="com.phodal.charj.parser.CharjParser"
  parserUtilClass="com.intellij.lang.parser.GeneratedParserUtilBase"
  psiImplUtilClass="com.phodal.charj.parser.CharjPsiImplUtil"

  implements="com.phodal.charj.psi.CharjPsiCompositeElement"
  extends="com.phodal.charj.psi.impl.CharjPsiCompositeElementImpl"

  psiClassPrefix="Charj"
  psiImplClassSuffix="Impl"
  psiPackage="com.phodal.charj.psi"
  psiImplPackage="com.phodal.charj.psi.impl"

  elementTypeHolderClass="com.phodal.charj.lexer.CharjTypes"
  elementTypeClass="com.phodal.charj.psi.CharjElementType"
  tokenTypeClass="com.phodal.charj.lexer.CharjTokenType"

  tokenTypeClass="com.phodal.charj.lexer.CharjTokenType"
  tokens = [
      MEMBER_PLACEHOLDER="member"

      COMMENT          = 'regexp://[^\r\n]*'
      BLOCK_COMMENT    = 'regexp:[/][*][^*]*[*]+([^/*][^*]*[*]+)*[/]'

      IDENTIFIER       = 'regexp:[_a-zA-Z][_a-zA-Z0-9]*'

      INT_KEYWORD      ='int'
      FLOAT_KEYWORD    ='float'
      STRING_KEYWORD   ='string'
      IN_KEYWORD       ='in'
      OUT_KEYWORD      ='out'
      MEMBER_KEYWORD   ='member'
      STRUCT_KEYWORD   ='struct'
      PKG_KEYWORD      ='pkg'
      PACKAGE_KEYWORD  ='package'
      IMPORT_KEYWORD   ='import'
      IN_KEYWORD       ='in'
      INSTANCE_KEYWORD ='instance'
      MATCH_KEYWORD    ='match'
      FX_KEYWORD       ='fx'
      IF_KEYWORD       ='if'
      ELIF_KEYWORD     ='elif'
      ELSE_KEYWORD     ='else'
      THEN_KEYWORD     ='then'
      END_KEYWORD      ='end'

      COLON          = ":"
      DOUBLE_COLON   = "::"
      SEMICOLON      = ";"
      SLASH          = "/"
      OPEN_BRACE     = "{"
      CLOSE_BRACE    = "}"
      COMMA          = ","
      EQUAL          = "="
      DOLLAR         = "$"
      QUOTA          = "'"
      LPAREN         = '('
      RPAREN         = ')'
  ]
}

compilationUnit ::= headers body { pin = 1}

headers ::= packageDeclaration importDeclaration?

packageDeclaration ::= (PACKAGE_KEYWORD | PKG_KEYWORD) package_name

importDeclaration ::= IMPORT_KEYWORD import

body ::= structDeclaration* memberDeclaration?

import ::= qualified_name

structDeclaration ::=
   DEF_KEYWORD? STRUCT_KEYWORD structNameDeclaration OPEN_BRACE memberDeclaration* CLOSE_BRACE
   | FX_KEYWORD structNameDeclaration DOLLAR functionDefineName functionParameters OPEN_BRACE memberDeclaration* CLOSE_BRACE
{
  mixin="com.phodal.charj.psi.impl.CharjNamedElementImpl"
  implements="com.phodal.charj.psi.CharjNamedElement"
  methods=[getName]
}

functionParameters ::=
    LPAREN inputParameters RPAREN outputParameters?
    | IN SUB GT inputParameters
    | outputParameters

inputParameters ::= parameter (COMMA parameter)?

outputParameters ::=
  OUT_KEYWORD parameter (COMMA parameter)?
 | SUB GT parameter (COMMA parameter)?

parameter ::= IDENTIFIER COLON parameterType

parameterType ::=
    primitive_type
  | IDENTIFIER

memberDeclaration ::=
   DEF_KEYWORD? MEMBER_PLACEHOLDER structNameDeclaration COLON primitive_type
  | exprDeclaration

primitive_type ::=
      INT_KEYWORD
  | FLOAT_KEYWORD
  | STRING_KEYWORD

exprDeclaration ::=
    functionName variableDeclaration COMMA variableDeclaration
  | primitive_type variableDeclaration EQUAL

variableDeclaration ::= name_component
functionName ::= name_component
functionDefineName ::= name_component
structNameDeclaration ::= name_component

package_name ::= qualified_name { name = 'package name' }

qualified_name ::= name_component ("." name_component)*

name_component ::= IDENTIFIER
{
  mixin="com.phodal.charj.psi.impl.CharjNamedElementImpl"
  implements="com.phodal.charj.psi.CharjNamedElement"

  methods=[
    getReference
  ]
}

